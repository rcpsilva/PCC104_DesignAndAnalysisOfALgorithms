1 - Why do we study algorithms:

- You have to know a standard set of important algorithms from different areas of computing; 
- You should be able to design new algorithms and analyze their efficiency.

There are several ohter reasons why we study algorithms:

Efficiency: We study algorithms to find efficient solutions to problems. An efficient algorithm is one that can solve a problem with minimal time and space complexity.

Correctness: We study algorithms to ensure that they are correct and produce the desired output for all possible inputs. A correct algorithm should always produce the correct output for any given input.

Abstraction: We study algorithms to understand how to abstract a problem into a set of instructions that can be implemented on a computer.

Reusability: We study algorithms to develop reusable solutions that can be used across different applications and domains.

Optimization: We study algorithms to optimize existing solutions and develop new solutions that can solve problems in a more efficient and effective manner.

In summary, studying algorithms helps us: 
 - Understand how to solve problems efficiently and correctly, 
 - Abstract a problems into a set of instructions, 
 - Develop reusable solutions, 
 - Optimize existing solutions.


2) An algorithm is a step-by-step procedure for solving a problem or accomplishing a task. It is a finite set of instructions that take some input, perform a series of computations, and produce an output.

More strictly, an algorithm is a sequence of unambiguous instructions for solving a problem, i.e., for obtaining a required output for any legitimate input in a finite amount of time.

3) 

function gcd(a, b)
    while b â‰  0
        t := b
        b := a mod b
        a := t
    return a

We can prove that the algorithm above stops by showing that the value of b decreases with each iteration of the while loop, and that eventually b will become zero, causing the loop to terminate.

The algorithm works by finding the greatest common divisor (GCD) of two numbers, a and b. In each iteration of the loop, the algorithm calculates the remainder of a divided by b, and assigns it to the variable b. Since the remainder is always less than b, the value of b decreases with each iteration of the loop.

Eventually, the algorithm will reach a point where the remainder of a divided by b is zero, meaning that b is a divisor of a. At this point, the loop will terminate, and the value of a, which has been progressively replaced with b during the iterations of the loop, will be the GCD of the original values of a and b.

Therefore, we can conclude that the algorithm always terminates and returns a result.

5) 

a) Understand the problem 
	- Identify what kind problem it is
	- Solve small instances by hand 
	- Think about scpecial cases

b) Define the expected capabilities of the computational device
	- Is the amount of memory a concern?
	- Is the processing capability a concern?
	
c) Define what kind of solution you need.
	- Exact -> May be too slow
	- Approximate -> Fast but may be innacurate
	
d) Select the algorithm design techinique and data structures

e) Prove corectness

f) Analyze the algorithm
	- Time efficiency
	- Space effiency
	- Simplicity -> Easier to understand, easier to debug, less likely to lead to bugs.
	- Generality
	
g) Code
	- Programming Language
	- Efficient implementation

9 - Time complexity refers to the amount of time it takes for an algorithm to run as a function of the input size.
Space complexity refers to the amount of memory or storage required by an algorithm as a function of the input size. 

10 - The best case refers to the scenario in which an algorithm performs in the most efficient manner possible, usually when the input is already sorted or some other advantageous condition is present. For example, the best case for a sorting algorithm might occur when the input is already sorted, in which case the algorithm could complete in O(n) time complexity.

The worst case refers to the scenario in which an algorithm performs in the least efficient manner possible, usually when the input is in a state that is most challenging for the algorithm to handle. For example, the worst case for a sorting algorithm might occur when the input is in reverse order, in which case the algorithm could take O(n^2) time complexity.

The average case refers to the scenario in which an algorithm performs in a typical manner, taking into account a distribution of possible inputs. This is often more difficult to define than the best and worst cases, as it depends on the specific distribution of inputs that the algorithm will encounter in practice. For example, the average case for a sorting algorithm might be when the input is randomly ordered, in which case the algorithm might take O(n log n) time complexity on average.

def sequential_search(lst, element):
    """
    Search for the given element in the list using sequential search.
    """
    for i in range(len(lst)):
        if lst[i] == element:
            return i
    return -1  # element not found in list

